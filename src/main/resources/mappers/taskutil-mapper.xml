<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="fury.deep.project_builder.repository.task.TaskUtilMapper">

    <delete id="deleteAssigneesByTaskId">
        DELETE
        FROM task_assignee
        WHERE task_id = #{taskId}
    </delete>

    <insert id="insertAssignees">
        INSERT INTO task_assignee (task_id, user_id)
        SELECT
        #{taskId},
        u.id
        FROM "user" u
        WHERE u.team_id = #{teamId}
        AND u.username IN
        <foreach collection="assignees"
                 item="username"
                 open="("
                 separator=","
                 close=")">
            #{username}
        </foreach>
    </insert>

    <delete id="deleteDependenciesByTaskId">
        DELETE
        FROM task_dependency
        WHERE task_id = #{taskId}
    </delete>

    <insert id="insertDependencies">
        INSERT INTO task_dependency (task_id, depends_on_task_id)
        SELECT
        #{taskId},
        t.id
        FROM task t
        WHERE t.project_id = #{projectId}
        AND t.id IN
        <foreach collection="dependencies"
                 item="dependencyId"
                 open="("
                 separator=","
                 close=")">
            #{dependencyId}
        </foreach>
    </insert>

    <!-- ========================= -->
    <!-- Cycle Detection (CORE)    -->
    <!-- ========================= -->

    <!--
        Checks whether adding:
            task_id -> depends_on_task_id
        would introduce a cycle.

        Logic:
        1. Start from the dependency task (dependsOnTaskId)
        2. Recursively walk its dependencies
        3. If we ever reach baseTaskId, a cycle exists

        This avoids loading the entire project dependency graph.
        Time complexity depends only on reachable subgraph.
    -->
    <select id="createsCycle" resultType="boolean">
        WITH RECURSIVE dependency_path AS (

            -- Step 1: Start from the immediate dependency
            SELECT td.depends_on_task_id
            FROM task_dependency td
            WHERE td.task_id = #{dependsOnTaskId}

            UNION ALL

            -- Step 2: Walk deeper dependencies
            SELECT td.depends_on_task_id
            FROM task_dependency td
                     JOIN dependency_path dp
                          ON td.task_id = dp.depends_on_task_id)

        -- Step 3: If base task is reachable, cycle exists
        SELECT EXISTS (SELECT 1
                       FROM dependency_path
                       WHERE depends_on_task_id = #{taskId})
    </select>

</mapper>
