<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="fury.deep.project_builder.repository.analytics.AnalyticsMapper">

    <!-- ===================== ENSURE ======================== -->
    <insert id="ensureProjectHealth">
        INSERT INTO project_health (project_id)
        VALUES (#{projectId}) ON CONFLICT DO NOTHING
    </insert>

    <insert id="ensureFlow">
        INSERT INTO project_flow_metrics (project_id)
        VALUES (#{projectId}) ON CONFLICT DO NOTHING
    </insert>

    <insert id="ensureDependency">
        INSERT INTO project_dependency_risk (project_id)
        VALUES (#{projectId}) ON CONFLICT DO NOTHING
    </insert>

    <insert id="ensureTeamCapacity">
        INSERT INTO team_capacity_analytics (team_id)
        VALUES (#{teamId}) ON CONFLICT DO NOTHING
    </insert>

    <!-- ===================== FLOW ========================== -->

    <!--
        Flow model
        ──────────
        wip       : tasks not yet completed
        t7 / t30  : completed within the last 7 / 30 days
        avgCycle  : average (completed_at − started_at) in whole days;
                    tasks missing either timestamp are excluded from the average
    -->
    <select id="selectFlowAgg" resultType="fury.deep.project_builder.dto.analytics.db.FlowAggRow">
    <![CDATA[
        SELECT #{projectId} AS projectId,
            COUNT(*) FILTER (WHERE status <> 'COMPLETED') AS wip,
            COUNT(*) FILTER (WHERE completed_at >= now() - INTERVAL '7 days') AS t7,
            COUNT(*) FILTER (WHERE completed_at >= now() - INTERVAL '30 days') AS t30,
            COALESCE(
                AVG(EXTRACT(EPOCH FROM (completed_at - started_at)) / 86400.0)
                FILTER(WHERE started_at IS NOT NULL AND completed_at IS NOT NULL),
                0)::int AS avgCycle
        FROM task
        WHERE project_id = #{projectId}
        ]]>
    </select>

    <update id="updateFlow">
        UPDATE project_flow_metrics
        SET wip_count           = #{wip},
            throughput_7d       = #{throughput7d},
            throughput_30d      = #{throughput30d},
            avg_cycle_time_days = #{avgCycle},
            updated_at          = now()
        WHERE project_id = #{projectId}
    </update>

    <!-- ================= DEPENDENCY RISK =================== -->

    <!--
        Dependency risk model (score 0–100)
        ────────────────────────────────────
        blocked ratio → 40 pts   (blocked / total deps)
        density       → 30 pts   (total deps / total tasks, capped at 1.0)
        critical path → 30 pts   (depth hops, capped at 10 → 3 pts each)

        The recursive CTE computes the longest dependency chain (critical path).
        It is bounded by Postgres's default cte_recursion_limit (default 1000).
        Add CYCLE detection if circular dependency prevention is not enforced
        at the application layer.
    -->
    <select id="selectDependencyAgg" resultType="fury.deep.project_builder.dto.analytics.db.DependencyAggRow">
    <![CDATA[
        WITH dep AS (SELECT td.task_id, td.depends_on_task_id, dep_task.status
                        FROM task_dependency td
                        JOIN task dep_task ON dep_task.id = td.depends_on_task_id
                        JOIN task t ON t.id = td.task_id
                        WHERE t.project_id = #{projectId}),
             depth AS (WITH RECURSIVE tree AS (SELECT task_id, depends_on_task_id, 1 AS d
                                               FROM dep
                                               UNION ALL
                                               SELECT t.task_id, d.depends_on_task_id, t.d + 1
                                               FROM tree t
                                               JOIN dep d ON t.depends_on_task_id = d.task_id)
                       SELECT COALESCE(MAX(d), 0) AS critical
                       FROM tree),
             totals AS (SELECT COUNT(*) AS task_count
                        FROM task
                        WHERE project_id = #{projectId})
        SELECT #{projectId} AS projectId,
                COUNT(*) AS total,
                COUNT(*) FILTER (WHERE status <> 'COMPLETED') AS blocked,
                (SELECT critical FROM depth) AS criticalPath,
                CASE
                   WHEN (SELECT task_count FROM totals) = 0 THEN 0.0
                   ELSE COUNT(*)::double precision / (SELECT task_count FROM totals)
                END AS density
        FROM dep
        ]]>
    </select>

    <update id="updateDependencyRisk">
        UPDATE project_dependency_risk
        SET total_dependencies       = #{total},
            blocked_dependency_count = #{blocked},
            critical_path_length     = #{criticalPath},
            dependency_density       = #{density},
            risk_score               = #{risk},
            updated_at               = now()
        WHERE project_id = #{projectId}
    </update>

    <!-- ================= TEAM CAPACITY ===================== -->
    <!--
        Team capacity model
        ───────────────────
        activeProjects : total projects belonging to the team
        activeTasks    : total non-completed tasks across all team projects
        avgTasks       : average active tasks per user (over users who have ≥1)
        overloaded     : users whose active task count exceeds #{overloadThreshold}
        avgCompletion  : avg(completed_at − started_at) in whole days for
                         tasks completed by team members;
                         tasks missing either timestamp are excluded
    -->
    <select id="selectTeamAgg"
            resultType="fury.deep.project_builder.dto.analytics.db.TeamAggRow">
    <![CDATA[
        WITH team_projects AS (SELECT id AS project_id
                               FROM project
                               WHERE team_id = #{teamId}),
             team_tasks AS (SELECT ta.user_id,
                                   t.id AS task_id,
                                   t.started_at,
                                   t.completed_at,
                                   t.status
                            FROM task_assignee ta
                                     JOIN task t ON t.id = ta.task_id
                            WHERE t.project_id IN (SELECT project_id FROM team_projects)),
             active_per_user AS (SELECT user_id, COUNT(*) AS cnt
                                 FROM team_tasks
                                 WHERE status <> 'COMPLETED'
                                 GROUP BY user_id)
        SELECT #{teamId}                                                     AS teamId,
               (SELECT COUNT(*) FROM team_projects)                          AS activeProjects,
               (SELECT COUNT(*) FROM team_tasks WHERE status <> 'COMPLETED') AS activeTasks,
               COALESCE((SELECT AVG(cnt) FROM active_per_user), 0)::int            AS avgTasks, (SELECT COUNT(*) FILTER (WHERE cnt > #{overloadThreshold})
                                                                                                 FROM active_per_user) AS overloaded,
               COALESCE(
                       AVG(EXTRACT(EPOCH FROM (completed_at - started_at)) / 86400.0)
                       FILTER(WHERE started_at IS NOT NULL AND completed_at IS NOT NULL),
                       0
               ) ::int                                                              AS avgCompletion
        FROM team_tasks
        ]]>
    </select>

    <update id="updateTeamCapacity">
        UPDATE team_capacity_analytics
        SET active_projects          = #{activeProjects},
            active_tasks             = #{activeTasks},
            avg_tasks_per_user       = #{avgTasks},
            overloaded_users         = #{overloaded},
            avg_completion_time_days = #{avgCompletion},
            burnout_risk_score       = #{burnout},
            updated_at               = now()
        WHERE team_id = #{teamId}
    </update>

    <!-- ================= PROJECT HEALTH ==================== -->
    <!--
        Health model
        ────────────
        overdue     : tasks past end_date and not completed
        longRunning : tasks started > 14 days ago with no completion
        blocked     : dependencies whose upstream task is not completed

        FIX: the orphaned `variance` parameter (overdue * 2) has been removed
             from updateProjectHealth.  It was never used in the SQL UPDATE.
    -->
    <select id="selectHealthAgg"
            resultType="fury.deep.project_builder.dto.analytics.db.HealthAggRow">
    <![CDATA[
        SELECT #{projectId} AS projectId,
            COUNT(*) FILTER (WHERE end_date < CURRENT_DATE AND status  <> 'COMPLETED') AS overdue,
            COUNT(*) FILTER (WHERE started_at IS NOT NULL AND completed_at IS NULL AND started_at < now() - INTERVAL '14 days') AS longRunning,
            (SELECT COUNT(*)
                FROM task_dependency td
                JOIN task dep_task ON dep_task.id = td.depends_on_task_id
                JOIN task t ON t.id = td.task_id
                WHERE t.project_id = #{projectId}
                AND dep_task.status <> 'COMPLETED') AS blocked
        FROM task
        WHERE project_id = #{projectId}
        ]]>
    </select>

    <update id="updateProjectHealth">
        UPDATE project_health
        SET overdue_tasks = #{overdue},
            blocked_tasks = #{blocked},
            health_score  = #{score},
            risk_level    = #{riskLevel},
            updated_at    = now()
        WHERE project_id = #{projectId}
    </update>

    <!-- ================= LOOKUPS =========================== -->
    <select id="findTeamByProject" resultType="string">
        SELECT team_id
        FROM project
        WHERE id = #{projectId}
    </select>

</mapper>